# JVM知识点

## JVM类加载子系统

* **类加载机制**

    通过一个**类的全限定名**来获取定义此类的**二进制字节流**，将这个字节流所代表的**静态存储结构**转化为**方法区**的运行时数据结构。 在**内存中**生成一个代表该类的`java.lang.Class`对象，作为**方法区该类的各种数据结构的访问入口**。
  * 加载(Loading)
  
  * 链接(Linking)
    * 验证(Verification)
      * 验证.class文件字节流正确性：文件格式、元数据、字节码、符号引用验证
    * 准备(Preparation)
      * 为**静态（类）变量**分配初始值（注意什么是静态变量，不包括**常量**， 类变量在方法区中）
      * jdk6运行时常量、静态变量、字符串常量池在方法区(Perm), jdk1.7/1.8运行时常量在方法区(MetaSpace)，静态变量、字符串常量池在堆中
    * 解析(Resolution)
      * 将常量池内的符号引用转化为直接引用（解析一般在JVM执行完**初始化**操作后才执行）
  
  * 初始化(Initialization)
    * 有<cinit>方法执行<cinit>方法，也就是把静态变量和静态代码块合并执行， **执行顺序为定义顺序**；注意：父类有<cinit>先执行父类的
    * 强调一下**成员变量**的初始化时间：java new关键字用来**分配对象空间并对其做默认初始化**，默认初始化会将对象的所有成员字段设到其类型对应的默认值（零值）。
而**构造器**用来初始化对象，执行构造方法中的代码，当然默认隐含了调用super父类构造。

* **运行时数据区**
  * **堆**
    
    * 所有线程共享（线程不安全）、堆大小可以调节、逻辑上是连续的内存空间、在堆上可以划分线程私有的缓冲区（TLAB：Thread Local Allocation Buffer），栈上的对象引用指向堆上的对象实例。
    * **几乎（JIT逃逸分析能让对象栈上分配）所有**的对象实例和数组都分配在堆上，堆是GC的重点区域。
    
    * 现代垃圾回收器大部分基于堆分代收集理论设计，所以堆空间在被在逻辑上被分代：
      * jdk1.7及之前 : 
        * 新生代（Young Generation Space，又叫Young区） = Eden区 + Survivor区（from + to两部分 或 叫S0和S1区）
        * 老年代（Tenure Generation Space，又叫Old/Tenure区） 
        * **永久代（Permanent Space，又叫Perm区）**
      * jdk1.8及之后 :
        * 新生代（Young Generation Space，又叫Young/New区） = Eden区 + Survivor区（from + to两部分 或 叫S0和S1区）
        * 老年代（Tenure Generation Space，又叫Old/Tenure区）
        * **元空间（Meta Space，又叫Meta）**
    
    * 堆区会产生OOM错误（Out Of Memory）
    
    * 堆的一些基本参数设置：
      * -Xms 256m（或-XX:InitialHeapSize 256m）堆起始大小256m。 默认： 物理内存大小/64
      * -Xmx 256m（或-XX:MaxHeapSize 256m）堆区最大内存256m。默认： 物理内存大小/4
      * -XX:NewRatio = 4， 表示新生代占1份，老年代占4份， 新生代占整个堆的1/5, 老年占整个堆的4/5
      * -XX:SurvivorRatio = 8， 表示新生代中 Eden:from:to = 8:1:1，默认是8:1:1
      * -Xmn 1G 可以直接指定新生代最大内存大小，一般为默认值不设置
      * -XX:MaxTenuringThreshold = <N> 表示 Survivor区中的对象经历多少次GC后会进入老年代
    
    * 对象分配过程：
      * 1.新创建的对象会入到堆中的Eden区
      * 2.Eden区大小不够时再创建新对象进来时，会进行垃圾回收（Minor GC/Young GC），未回收的对象进S0区，新进行来的对象依旧分配到Eden区
      * 3.S0和S1复制是交替的，一般GC复制后S0和S1哪个区域空哪个区域就是to区。
      * 4.对象在新生代经历过-XX:MaxTenuringThreshold = <N>次GC后未被回收直接进入老年代（还有一种情况是对象过大直接进入老年代，放不下触发Old GC）
      * 5.老年代不足时先触发老年代GC（Major GC/Old GC），GC后不足以把对象入到老年代则OOM。 

  * **栈（虚拟机栈）**  
    * 为了实现跨平台的设计，Java指令基于栈来设计， 优点：指令集小，易实现；缺点：性能下降，需要更多的指令。
    * 栈是运行时的单位，解决的是程序运行时如何执行，如何处理数据。（堆是存储单位，解决数据如何存储的问题）
    * 生命周期与线程一致，线程销毁，栈也没了。栈不存在垃圾回收问题。不被线程共享，栈相应的也是线程安全的。
    * Java虚拟机规范规定：栈大小可以是动态的或固定， 固定的话会出现`StackOverflowError`，动态扩展的话申请内存不够或申请了不够栈创建会出现`OutOfMemoryError`。
    
    * **控制栈大小的虚拟机参数：-Xss 1k**  
    * **栈中的存储单元：栈帧，一个栈帧对应我们Java类中的一个方法** （与栈数据结构一样，**后进先出**）
      * 一条活动的线程在一个时间点上只会执行一个栈帧， 这个栈帧在栈的栈顶，叫做**当前栈帧**， 对应的方法叫**当前方法**，对应的类叫**当前类**，在栈中调用了其他方法，那其他方法对应栈帧会推到栈顶，成为新的当前栈。**JVM执行引擎运行的字节码指令只针对当前栈帧**。
    
    * **栈帧结构：**
      * **局部变量表（Local Variables）**
        * 是一个**数组**，其存储单位是变量槽（Slot），索引从0开始到数组长度减1，用来存储**方法入参**和**方法体内的局部变量**，数据类型包括：基本类型、引用类型、方法返回地址。
        * 建立在线程私有的栈上，没有线程安全问题。（其实这里需要注意一下：假如入参是个HashMap（传入的是地址引用拷贝）, 在其他地方其他线程操作时其实是线程不安全的）
        * **局部变量表容量大小在编译期确定下来，变量表与操作数栈配合来完成指令执行过程中的数值传递**
        * **变量槽（Slot）**:32位内的类型占用1个槽（包括ReturnAddress），64位类型占用2个槽（long、double）
          * 当一个实例方法被调用时，该方法的参数和方法内的局部变量会按照顺序被复制到局部变量表中的每一个槽上。
          * 如果当前帧由构造方法或实例方法创建，this变量会被入到局部变量表第0个槽上，其他的按顺序放。
          * 变量槽是可以复用的，有变量作用域过了就能复用这个过期变量的槽。
          * 变量槽访问是根据索引访问的。（在Idea中断点时可以打开这个变量槽显示： Slot_N）
          * **局部变量表中的变量是垃圾回收GC Root之一，前提是只要变量不被直接或间接引用。**
    
      * **操作数栈（Operand Stack）**
        * ”先进后出“，在执行指令过程中，只有往栈中读取或写入数据，访问数据的方式就是出栈/入栈。**主要是用于保存计算的中间结果或作用计算过程中变量的存储空间。**
        * 是JVM执行引擎的一个工作区域，栈帧（也即方法）新创建出来时操作数栈是空的。
        * 有最大深度max_stack，在编译期确定，保存在方法字节码的Code区，同样的32位类型占1个栈，64位类型占2个栈。栈类型与数据类型严格匹配，在编译期和类加载验证阶段都会校验。
        * **如果方法有返回值在方法返回时返回值会被压入到栈顶，同时会更新PC寄存器下一条需要执行的指令地址。**
      
      * **动态链接（Dynamic Linking）**：
        * 字节码文件中所有方法、变量都是**符号引用**保存在class文件的常量池中，动态链接作用就是将符号引用转换为直接引用。
        * 每一个栈帧内部都有一个指定运行时常量池中的该栈栈帧所属的方法引用。
        * 动态链接与静态链接 ：
          * 在.class字节码被装入到JVM中时，一个被调用**目标方法在编译期可知且在运行时保持不变**，会将该方法的**符号引用转换成直接引用**的过程叫静态链接。反之在编译器无法确定就是动态链接，也无法将符号引用转换为直接引用。
        
        * 对应方法的**绑定机制**：
          * 早期绑定 ： **目标方法在编译期可知且在运行时保持不变**，就能将方法与所属类绑定，就可以使用静态链接将符号引用转为直接引用。
          * 晚期绑定 ： **编译期不可知，只能在运行期根据实际类型绑定相关的方法**
        
        * 非虚方法：在编译期就能确定具体的调用版本，在运行期不可变的方法。
          * 静态方法、私有方法、final方法、构造方法、父类方法都属于非虚方法（解析阶段就能确定），其他属于虚方法。
        * 如何调用虚方法和非虚方法？
          * 普通调用指令：（下面4条指令进行的方法调用不可人为干预）
            * invokestatic： 调用静态方法，解析阶段能唯一确定
            * invokespecial： 调用构方法（<init>方法）、私有方法、父类方法，解析阶段能唯一确定
            * invokevirtual： 调用所有虚方法
            * invokeinterface： 调用接口方法
          * 动态指令：
            * invokedynamic（Java7新指令）：动态解析出调用的方法，然后执行。（如Java7中借助ASM来调用该指令、Java8的lambda表达式）
        * 虚方法表：每一个类有一个虚方法表，包含所有虚方法，用来提高性能。
        * **多态的本质（运行时多态）：晚期绑定确定实际类型。** （编译期多态：重载方法，在编译期能唯一确定）
        
      * 方法返回地址（Return Address）
        * 方法返回两种方式： 正常返回、出现异常， 无论通过哪种方式都返回到该方法被调用的位置。正常返回：PC程序计数器的值为返回值（有的话）地址，调用指令指向下一条。异常返回：查异常表，不会给调用上层返回任何值。
        * 方法的退出就是栈帧出栈，此时要恢复上层的局部变量表，PC，操作数栈及将返回值压入操作数栈。
        * 方法返回指令: ireturn、arreturn等等，可查文档。 JVM遇到返回指令就把正常返回值返回给上层调用。
        
      * 附加信息
        * 如对调用程序提供支持的信息
  
  * **方法区**
      
    * 就HotSpot而言，方法区叫做非堆（Non-Heap），是独立于Java堆的内存空间，该区域**所有线程共享**，空间区域大小可通过参数配置。
  
    * **方法区的内部结构**：    
      * 类型信息（如类Class、接口Interface、枚举Enum、注解Annotation类）： 包括修饰符、直接父类的有效名称、全限定名、类的直接接口组成的列表
      * 域信息： 包括域名称、域类型、域修饰符
      * 方法信息：包括名称、返回值、参数个数及类型、修饰符、方法字节码、操作数栈、局部变量表及大小、异常表
      * 编译器编译后的代码缓存
      * 全局常量：被static final修饰且在编译期就确定了的值
      * 静态变量
      * **虚方法表也在方法区中，每个类都有一个虚方法表！（虚方法表创建时机：类的链接阶段到初始化阶段）**

    * 不同版本的方法区：
      * jdk1.7及以前： **永久代（Permanent Generation）**
        * -XX:PermSize=<N> 初始永久代空间大小设置，默认20.75m
        * -XX:MaxPermSize=<N> 永久代最大空间大小设置， 32位默认64m， 64位置默认82m
        
      * jdk1.8及以后： **元空间（Meta Space）**，元空间使用本地内存。
        * -XX:MetaSpaceSize=<N> 初始元空间大小设置
        * -XX:MaxMetaSpaceSize=<N> 最大元空间大小设置
        * 默认值依赖于平台，不指定大小元空间可能会耗尽系统内存，触发OOM。-XX:MetaSpaceSize有可重置的水位线，超过水位线会触发Full GC。
    
    * HotSpot方法区的变化：
      * jdk1.6及以前：叫永久代（Permanent Generation）， **运行时常量池**（**字符串常量池StringTable也在运行时常量池中**） 和 **静态变量**在永久代中
      * jdk1.7：叫永久代（Permanent Generation），**运行时常量池**在永久代中， **静态变量**和**字符串常量池StringTable**在**堆**中
      * jdk1.8：叫元空间（Meta Space），使用**本地内存**，**运行时常量池**在元空间中，**静态变量**和**字符串常量池StringTable**在**堆**中

    * 方法区的垃圾回收：
      * 主要回收**常量池中不被引用的常量**和**类型信息**（可以通过-Xnoclassgc来控制），类型信息回收很严格： 该类的对象没了 + 加载该类的类加载器没了 + 该的`java.lang.Class`对象没了。
      * 注：类加载和卸载可以用 -XX:+TraceClassLoading 和 -XX:-TraceClassUnLoading来观察
 
  * **本地方法栈**
  * **程序计数器**