# JVM知识点

## JVM类加载子系统

* **类加载机制**

通过一个**类的全限定名**来获取定义此类的**二进制字节流**，将这个字节流所代表的**静态存储结构**转化为**方法区的运行时数据结构。 在**内存中**生成一个代码**该类的`java.lang.Class`对象，作为**方法区该类的各种数据结构的访问入口**。
  * 加载(Loading)
  * 链接(Linking)
    * 验证(Verification)
      * 验证.class文件字节流正确性：文件格式、元数据、字节码、符号引用验证
    * 准备(Preparation)
      * 为**静态（类）变量**分配初始值（注意什么是静态变量，不包括**常量**， 类变量在方法区中）
      * jdk6运行时常量、静态变量、字符串常量池在方法区(Perm), jdk1.7/1.8运行时常量在方法区(MetaSpace)，静态变量、字符串常量池在堆中
    * 解析(Resolution)
      * 将常量池内的符号引用转化为直接引用（解析一般在JVM执行完**初始化**操作后才执行）
  * 初始化(Initialization)
    * 有<cinit>方法执行<cinit>方法，也就是把静态变量和静态代码块合并执行， **执行顺序为定义顺序**；注意：父类有<cinit>先执行父类的
    * 强调一下**成员变量**的初始化时间，java new关键字用来**分配对象空间并对其做默认初始化**，默认初始化会将对象的所有成员字段设到其类型对应的默认值（零值）。
而**构造器**用来初始化对象，执行构造方法中的代码，当然默认隐含了调用super父类构造。