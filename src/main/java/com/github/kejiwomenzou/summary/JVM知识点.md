# JVM知识点梳理
 
## JVM类加载子系统

### 类加载机制

  通过一个**类的全限定名**来获取定义此类的**二进制字节流**，将这个字节流所代表的**静态存储结构**转化为**方法区**的运行时数据结构。 在**内存中**生成一个代表该类的`java.lang.Class`对象，作为**方法区该类的各种数据结构的访问入口**。

  * 加载(Loading)
  
  * 链接(Linking)
    * 验证(Verification)
      * 验证.class文件字节流正确性：文件格式、元数据、字节码、符号引用验证
    * 准备(Preparation)
      * 为**静态（类）变量**分配初始值（注意什么是静态变量，不包括**常量**， 类变量在方法区中）
      * jdk6运行时常量、静态变量、字符串常量池在方法区(Perm), jdk1.7/1.8运行时常量在方法区(MetaSpace)，静态变量、字符串常量池在堆中
    * 解析(Resolution)
      * 将常量池内的符号引用转化为直接引用（解析一般在JVM执行完**初始化**操作后才执行）
  
  * 初始化(Initialization)
    * 有<cinit>方法执行<cinit>方法，也就是把静态变量和静态代码块合并执行， **执行顺序为定义顺序**；注意：父类有<cinit>先执行父类的
    * 强调一下**成员变量**的初始化时间：java new关键字用来**分配对象空间并对其做默认初始化**，默认初始化会将对象的所有成员字段设到其类型对应的默认值（零值）。
而**构造器**用来初始化对象，执行构造方法中的代码，当然默认隐含了调用super父类构造。

### 类加载器与双亲委派模型

* **类加载器**： 
    * 所有的Class都是由类加载器ClassLoader加载的。
      * JVM支持以下类加载器：
        * 启动类加载器（Bootstrap ClassLoader）：c/c++实现，嵌套在JVM内部，用于加载JAVA_HOME/jre/lib/rt.jar或sun.boot.class.path下的内容。
    用于提供JVM自身需要的类，该类加载器的父类加载器为null。出于安全考虑：只加载包名为java、javax、sun等开头的包。
        * 扩展类加载器（Extension ClassLoader）：父类加载器是**启动类加载器**，继承自ClassLoader类，由sun.misc.Launcher$ExtClassLoader实现，用于
    加载java.ext.dirs目录或JAVA_HOME/jre/lib/ext/子目录下的类
        * 应用类加载器（Application ClassLoader）：父类加载器是**扩展类加载器**，继承自ClassLoader类，由sun.misc.Launcher$AppClassLoader实现，用于
          加载java.class.path目录或环境变量classpath下的类。**应用程序中默认是类加载器是应用类加载器**。
        * 用户自定义类加载器：自定义类加载器能实现应用隔离和插件机制（如Eclipse插件）。
      
* **双亲委派模型**:
  * 本质：规定了类加载的顺序，启动类加载器先加载，若加载不到，由扩展类加载器，还加载不到，才由应用类加载器或用户自定义类加载器加载。**已加载过的类不再加载**。
  * 优点：避免重复加载，保证核心API安全。
  * 缺点：上层无法访问到下层类加载器加载的类
  * 三次破坏双亲委派模型：jdk1.2之前（没有该机制，所以算破坏了）、线程上下文类加载器、热部署和热替换技术 

  * **ClassLoader源码解析**

  * **类的主动使用与被动使用**
    * Class只有在首次使用的时候才会被初始化，一个类或接口在首次使用前必须要对期进行初始化， 类的主动使用会触发类加载：加载、链接、初始化几个阶段（代码中的静态变量，静态代码块，成员变量初始化，注意细节）
  
    * **被动使用不会对类进行初始化操作**
  
    * 主动使用触发类初始化的场景：
      * 创建一个类的实例，如new，反射，克隆，反序列等
      * 当使用**类或接口的静态字段或静态方法**（注意final常量不算，注意细节）
      * java.lang.reflect下的Class.forName("xxx")方法
      * 初始化子类时，发现父类没有初始化，会先初始化父类（这条规则不适用于接口，什么时候会初始化接口：使用接口的静态字段或静态方法）
        * 初始化一个类时，并不会初始化其实现的接口
        * 初始化一个接口时，并不会初始化其父接口
      * 接口的default方法被子类实现了，直接或间接实现了该接口方法的类，需要保证接口在实现类之前被初始化
      * 用户指定虚拟机启动时执行类（main()方法的那个类），要被初始化
      * 初次调用MethodHandle实例时，初始化该MethodHandle所指向的方法所在的类

## 对象创建过程与对象内布局

### 对象的实例化：
#### 创建对象的方式：
  * new关键字
  * `Class.newInstance()`
  * `Constructor.newInstance(xxx)`
  * 使用Clone
  * 反序列化
  * 使用Objenesis库

#### 创建对象过程：
  * 1.判断对象对应的类是否已经加载、链接、初始化
  * 2.为对象分配内存： **根据堆内存是否规整区分分配方式，堆内存是否规整取决于GC回收器使用的回收算法。**
    * 内存规整：GC收集器使用**标记-压缩（标记-整理）**或**复制**算法时内存是规整的，此时使用**指针碰撞**分配方式，典型GC回收器是：Serial、ParNew
    * 内存不规整：GC收集器使用**标记-清除**算法时内存是不规整的，此时使用**空闲列表**（该列表JVM维护）分配方式,典型GC回收器是：CMS
  * 3.需要处理分配时的并发安全问题： CAS原子更新 或 线程预分配 （TLAB）
  * 4.初始化分配的空间 ： 对象实例字段设置默认值，保证在不显示赋值时可以直接使用。
  * 5.设置对象的对象头
  * 6.调用init（构造方法）方法进行初始化

### 对象内存布局：

64位虚拟机引入了**压缩指针**概念，用于压缩数据。涉及到性能优化与伪共享相关知识

#### 对象头：
  * Mark Word : 哈希值（hashcode） + GC分代年龄 + 锁状态标志位（无锁、轻量级锁、重量级锁） + 持有线程的锁 + 偏向线程ID + 偏向时间戳
  * 类型指针： 指向类元数据InstanceKlass，确定该对象所属的类型
  * 如果是数组的话，还需记录数组的长度

#### 实例数据：
  * 对象真正存储的有效信息，程序代码中定义的各种字段（包括自己的和从父类继承下来的）
  * 存放规则：
    * 相同宽度的字段总是被分配在一起
    * 父类定义的变量会出现在子类之前
    * CompactFields = true: 表示子类的窄变量可能会出现在父类的变量之间
    
#### 填充对齐
  * 补充字节而已

## JVM运行时数据区介绍

### 运行时数据区
  #### 堆
    
  * 所有线程共享（线程不安全）、堆大小可以调节、逻辑上是连续的内存空间、在堆上可以划分线程私有的缓冲区（TLAB：Thread Local Allocation Buffer），栈上的对象引用指向堆上的对象实例。
  * **几乎（JIT逃逸分析能让对象栈上分配）所有**的对象实例和数组都分配在堆上，堆是GC的重点区域。
  
  * 现代垃圾回收器大部分基于堆分代收集理论设计，所以堆空间在被在逻辑上被分代：
    * jdk1.7及之前 : 
      * 新生代（Young Generation Space，又叫Young区） = Eden区 + Survivor区（from + to两部分 或 叫S0和S1区）
      * 老年代（Tenure Generation Space，又叫Old/Tenure区） 
      * **永久代（Permanent Space，又叫Perm区）**
    * jdk1.8及之后 :
      * 新生代（Young Generation Space，又叫Young/New区） = Eden区 + Survivor区（from + to两部分 或 叫S0和S1区）
      * 老年代（Tenure Generation Space，又叫Old/Tenure区）
      * **元空间（Meta Space，又叫Meta）**
  
  * 堆区会产生OOM错误（Out Of Memory）
  
  * 堆的一些基本参数设置：
    * -Xms 256m（或-XX:InitialHeapSize 256m）堆起始大小256m。 默认： 物理内存大小/64
    * -Xmx 256m（或-XX:MaxHeapSize 256m）堆区最大内存256m。默认： 物理内存大小/4
    * -XX:NewRatio = 4， 表示新生代占1份，老年代占4份， 新生代占整个堆的1/5, 老年占整个堆的4/5
    * -XX:SurvivorRatio = 8， 表示新生代中 Eden:from:to = 8:1:1，默认是8:1:1
    * -Xmn 1G 可以直接指定新生代最大内存大小，一般为默认值不设置
    * -XX:MaxTenuringThreshold = <N> 表示 Survivor区中的对象经历多少次GC后会进入老年代
  
  * 对象分配过程：
    * 1.新创建的对象会入到堆中的Eden区
    * 2.Eden区大小不够时再创建新对象进来时，会进行垃圾回收（Minor GC/Young GC），未回收的对象进S0区，新进行来的对象依旧分配到Eden区
    * 3.S0和S1复制是交替的，一般GC复制后S0和S1哪个区域空哪个区域就是to区。
    * 4.对象在新生代经历过-XX:MaxTenuringThreshold = <N>次GC后未被回收直接进入老年代（还有一种情况是对象过大直接进入老年代，放不下触发Old GC）
    * 5.老年代不足时先触发老年代GC（Major GC/Old GC），GC后不足以把对象入到老年代则OOM。 

#### 栈（虚拟机栈）
  * 为了实现跨平台的设计，Java指令基于栈来设计， 优点：指令集小，易实现；缺点：性能下降，需要更多的指令。
  * 栈是运行时的单位，解决的是程序运行时如何执行，如何处理数据。（堆是存储单位，解决数据如何存储的问题）
  * 生命周期与线程一致，线程销毁，栈也没了。栈不存在垃圾回收问题。不被线程共享，栈相应的也是线程安全的。
  * Java虚拟机规范规定：栈大小可以是动态的或固定， 固定的话会出现`StackOverflowError`，动态扩展的话申请内存不够或申请了不够栈创建会出现`OutOfMemoryError`。

  * **控制栈大小的虚拟机参数：-Xss 1k**  
  * **栈中的存储单元：栈帧，一个栈帧对应我们Java类中的一个方法** （与栈数据结构一样，**后进先出**）
    * 一条活动的线程在一个时间点上只会执行一个栈帧， 这个栈帧在栈的栈顶，叫做**当前栈帧**， 对应的方法叫**当前方法**，对应的类叫**当前类**，在栈中调用了其他方法，那其他方法对应栈帧会推到栈顶，成为新的当前栈。**JVM执行引擎运行的字节码指令只针对当前栈帧**。

  * **栈帧结构：**
    * **局部变量表（Local Variables）**
      * 是一个**数组**，其存储单位是变量槽（Slot），索引从0开始到数组长度减1，用来存储**方法入参**和**方法体内的局部变量**，数据类型包括：基本类型、引用类型、方法返回地址。
      * 建立在线程私有的栈上，没有线程安全问题。（其实这里需要注意一下：假如入参是个HashMap（传入的是地址引用拷贝）, 在其他地方其他线程操作时其实是线程不安全的）
      * **局部变量表容量大小在编译期确定下来，变量表与操作数栈配合来完成指令执行过程中的数值传递**
      * **变量槽（Slot）**:32位内的类型占用1个槽（包括ReturnAddress），64位类型占用2个槽（long、double）
        * 当一个实例方法被调用时，该方法的参数和方法内的局部变量会按照顺序被复制到局部变量表中的每一个槽上。
        * 如果当前帧由构造方法或实例方法创建，this变量会被入到局部变量表第0个槽上，其他的按顺序放。
        * 变量槽是可以复用的，有变量作用域过了就能复用这个过期变量的槽。
        * 变量槽访问是根据索引访问的。（在Idea中断点时可以打开这个变量槽显示： Slot_N）
        * **局部变量表中的变量是垃圾回收GC Root之一，前提是只要变量不被直接或间接引用。**

    * **操作数栈（Operand Stack）**
      * ”先进后出“，在执行指令过程中，只有往栈中读取或写入数据，访问数据的方式就是出栈/入栈。**主要是用于保存计算的中间结果或作用计算过程中变量的存储空间。**
      * 是JVM执行引擎的一个工作区域，栈帧（也即方法）新创建出来时操作数栈是空的。
      * 有最大深度max_stack，在编译期确定，保存在方法字节码的Code区，同样的32位类型占1个栈，64位类型占2个栈。栈类型与数据类型严格匹配，在编译期和类加载验证阶段都会校验。
      * **如果方法有返回值在方法返回时返回值会被压入到栈顶，同时会更新PC寄存器下一条需要执行的指令地址。**
  
    * **动态链接（Dynamic Linking）**：
      * 字节码文件中所有方法、变量都是**符号引用**保存在class文件的常量池中，动态链接作用就是将符号引用转换为直接引用。
      * 每一个栈帧内部都有一个指定运行时常量池中的该栈栈帧所属的方法引用。
      * 动态链接与静态链接 ：
        * 在.class字节码被装入到JVM中时，一个被调用**目标方法在编译期可知且在运行时保持不变**，会将该方法的**符号引用转换成直接引用**的过程叫静态链接。反之在编译器无法确定就是动态链接，也无法将符号引用转换为直接引用。
    
      * 对应方法的**绑定机制**：
        * 早期绑定 ： **目标方法在编译期可知且在运行时保持不变**，就能将方法与所属类绑定，就可以使用静态链接将符号引用转为直接引用。
        * 晚期绑定 ： **编译期不可知，只能在运行期根据实际类型绑定相关的方法**
    
      * 非虚方法：在编译期就能确定具体的调用版本，在运行期不可变的方法。
        * 静态方法、私有方法、final方法、构造方法、父类方法都属于非虚方法（解析阶段就能确定），其他属于虚方法。
      * 如何调用虚方法和非虚方法？
        * 普通调用指令：（下面4条指令进行的方法调用不可人为干预）
          * invokestatic： 调用静态方法，解析阶段能唯一确定
          * invokespecial： 调用构方法（<init>方法）、私有方法、父类方法，解析阶段能唯一确定
          * invokevirtual： 调用所有虚方法
          * invokeinterface： 调用接口方法
        * 动态指令：
          * invokedynamic（Java7新指令）：动态解析出调用的方法，然后执行。（如Java7中借助ASM来调用该指令、Java8的lambda表达式）
      * 虚方法表：每一个类有一个虚方法表，包含所有虚方法，用来提高性能。
      * **多态的本质（运行时多态）：晚期绑定确定实际类型。** （编译期多态：重载方法，在编译期能唯一确定）
    
    * 方法返回地址（Return Address）
      * 方法返回两种方式： 正常返回、出现异常， 无论通过哪种方式都返回到该方法被调用的位置。正常返回：PC程序计数器的值为返回值（有的话）地址，调用指令指向下一条。异常返回：查异常表，不会给调用上层返回任何值。
      * 方法的退出就是栈帧出栈，此时要恢复上层的局部变量表，PC，操作数栈及将返回值压入操作数栈。
      * 方法返回指令: ireturn、arreturn等等，可查文档。 JVM遇到返回指令就把正常返回值返回给上层调用。
    
    * 附加信息
      * 如对调用程序提供支持的信息

#### 方法区
      
  * 就HotSpot而言，方法区叫做非堆（Non-Heap），是独立于Java堆的内存空间，该区域**所有线程共享**，空间区域大小可通过参数配置。

  * **方法区的内部结构**：    
    * 类型信息（如类Class、接口Interface、枚举Enum、注解Annotation类）： 包括修饰符、直接父类的有效名称、全限定名、类的直接接口组成的列表
    * 域信息： 包括域名称、域类型、域修饰符
    * 方法信息：包括名称、返回值、参数个数及类型、修饰符、方法字节码、操作数栈、局部变量表及大小、异常表
    * 编译器编译后的代码缓存
    * 全局常量：被static final修饰且在编译期就确定了的值
    * 静态变量
    * **虚方法表也在方法区中，每个类都有一个虚方法表！（虚方法表创建时机：类的链接阶段到初始化阶段）**

  * 不同版本的方法区：
    * jdk1.7及以前： **永久代（Permanent Generation）**
      * -XX:PermSize=<N> 初始永久代空间大小设置，默认20.75m
      * -XX:MaxPermSize=<N> 永久代最大空间大小设置， 32位默认64m， 64位置默认82m
      
    * jdk1.8及以后： **元空间（Meta Space）**，元空间使用本地内存。
      * -XX:MetaSpaceSize=<N> 初始元空间大小设置
      * -XX:MaxMetaSpaceSize=<N> 最大元空间大小设置
      * 默认值依赖于平台，不指定大小元空间可能会耗尽系统内存，触发OOM。-XX:MetaSpaceSize有可重置的水位线，超过水位线会触发Full GC。
  
  * HotSpot方法区的变化：
    * jdk1.6及以前：叫永久代（Permanent Generation）， **运行时常量池**（**字符串常量池StringTable也在运行时常量池中**） 和 **静态变量**在永久代中
    * jdk1.7：叫永久代（Permanent Generation），**运行时常量池**在永久代中， **静态变量**和**字符串常量池StringTable**在**堆**中
    * jdk1.8：叫元空间（Meta Space），使用**本地内存**，**运行时常量池**在元空间（本地内存）中，**静态变量**和**字符串常量池StringTable**在**堆**中

  * 方法区的垃圾回收：
    * 主要回收**常量池中不被引用的常量**和**类型信息**（可以通过-Xnoclassgc来控制），类型信息回收很严格： 该类的对象没了 + 加载该类的类加载器没了 + 该的`java.lang.Class`对象没了。
    * 注：类加载和卸载可以用 -XX:+TraceClassLoading 和 -XX:-TraceClassUnLoading来观察

#### 本地方法栈
  * 本地方法栈是线程私有的，也就是经常看到的native方法，被调用后不受JVM控制。

####  程序计数器
  * 用来存储即将要执行的指令的地址，由执行引擎执行。
  * 程序计数器用内存很小，可以忽略不计，同时访问速度快
  * 任何时候一个线程只有一个方法在执行，即当前方法，PC存储了执行当前方法的指令地址，若是本地方法存储的是undefind

## Java中的”常量池“: 
   参考[知乎回答：Java 中new String("字面量") 中 "字面量" 是何时进入字符串常量池的?](https://www.zhihu.com/question/55994121/answer/147296098) 
    

#### 运行时常量池：
  * 方法区中的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有**常量池(Constant Pool Table)**，存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的**运行时常量池**。

#### 全局字符串常量池（StringTable）：
  * HotSpot VM里，记录interned string的一个全局表叫做StringTable。这是个纯运行时的结构，而且是惰性（lazy）维护的。注意它只存储对java.lang.String实例的引用，而不存储String对象的内容。 注意，它只存了引用，根据这个引用可以得到具体的String对象。一般我们说一个字符串进入了全局的字符串常量池其实是说在这个StringTable中保存了对它的引用
  * 字符串常量进入StringTable时机： ldc指令
  * [jdk9中String存储结构变更了](https://openjdk.org/jeps/254)。
  * jdk1.6在永久代，jdk1.7及1.8在堆中
  * G1垃圾回收器能指定参数在垃圾回收时检查是否对字符串去重。-XX:+UseStringDeduplication、-XX:StringTableSizen=n

#### class文件中的常量池：（Class结构内部部分会提到）
  * 1.Class文件中的常量池这里面主要存放两大类常量：
    * 字面量(Literal)：文本字符串等
    * 符号引用(Symbolic References)：
      * I.类和接口的全限定名(Full Qualified Name)		
      * II.字段的名称和描述符(Descriptor)		
      * III.方法的名称和描述符

## JVM垃圾回收机制: 
### 垃圾回收算法: 
* **垃圾标记阶段**：
  * **引用计数法**：
    * 每个对象保存一个整型的计数器属性，用于被引用情况。
    * 优点：简单、判定效率高、无延时性；缺点：存储和时间开销增大、无法解决循环引用问题。
    
  * **可达性分析算法**：
    * 以GC Roots为根集合搜索连接的对象是否达，搜索路径称为引用链，没有引用链接的对象标记为垃圾对象。
    * **使用可达性分析，需要在一致性快照中完成，GC收集时必须要“Stop The World”**。
    * **Java中哪些对象会作为GC Roots?** 
      * 虚拟机栈中引用的对象 ： 如各个线程中被调用方法中使用到的参数、局部变量等。
      * 方法区中静态属性引用的对象 ： Java类中的引用类型静态变量。
      * 方法区中的常量引用对象：字符串常量池（StringTable）中的引用。
      * 所有被`synchronized`锁持有的对象
      * 本地方法栈内JNI引用的对象（native方法中）
      * Java虚拟机内部的引用对象： 异常对象、基础类型对应的Class对象、系统类加载器
      * 反应JVM内部的JMXBean对象、JVMTI中注册的回调、本地代码缓存
  
* **垃圾清除阶段**：以下三种JVM目前比较常用的垃圾收集算法

  * **标记-清除（Mark-Sweep）算法**: 
    * **执行过程：**
      * **标记阶段**：收集器从GC Roots开始进行可达性分析，进行标记。可达对象一般标记在对象Head中
      * **清除阶段**：收集器对堆内存进行线性遍历，遇到不可达对象就将期回收（回收是指记录到空闲列表）。
    * **缺点**：效率不算高、GC过程会STW、产生内存碎片，需要维护空闲列表。

  * **复制（Copying）算法**

  * **标记-压缩（整理）（Mark-Compact）算法:** 又叫 **标记-清除-（整理）压缩算法**，是基于老年代特性的回收算法。
    * **执行过程：**
      * **第一阶段：** 等同于**标记-清除算法**，既进行可达性分析，还进行清除回收，不过**不需要维护空闲列表**了。
      * **第二阶段：** 把存活的对象压到内存一边，按顺序排放。当然这样需要把原来活的对象内存地址更新成新内存地址。

    * **优点**：
      * 对比**复制算法**，内存消耗减半
      * 对比**标记-清除算法**，消除了内存区域分散
    * **缺点**：
      * 效率低于**复制算法**
      * 移动对象的同时如果被其他对象引用需要调整其他对象原来引用的地址 
      * **移动过程中STW，相当于标记-压缩算法两个阶段都会STW**.
  
* **分代收集算法**：

* **增量收集算法**：

* **分区算法**：

